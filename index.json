[{"content":" 在写业务代码的时候我们经常需要判断 2 个 Java 对象是否一样，常用判断对象是否相等可以使用 == 、equals、hashcode 这 3 个方法，本文试图搞清楚这三者的用法。\n关系操作符== 使用 == 判断 2 个对象是否相等，判断的是这 2 个对象的地址是否相等。\n示例代码：\npublic class Test { public static void main(String[] args) { Person jack = new Person(); Person tom = new Person(); Person bob = jack; System.out.println(\u0026#34;jack == tom ? \u0026#34; + (jack == tom)); System.out.println(\u0026#34;jack == bob ? \u0026#34; + (jack == bob)); System.out.println(\u0026#34;jack 地址: \u0026#34; + jack); System.out.println(\u0026#34;tom 地址: \u0026#34; + tom); System.out.println(\u0026#34;bob 地址: \u0026#34; + bob); } } 输出结果：\njack == tom ? false jack == bob ? true jack 地址: com.mingyu.javalearn.Person@1b2c6ec2 tom 地址: com.mingyu.javalearn.Person@4edde6e5 bob 地址: com.mingyu.javalearn.Person@1b2c6ec2 可以看出 jack 和 tom 虽然是 new 新建同一个 Person，但是新建出来的 Person 的对象地址是不一样的，所以 jack 是不等于 tom 的，可以从打印出来的地址结果看出 jack 与 bob 的对象地址一样，所以它俩比较的结果为 true\nEquals() 方法 Java 中所有类都有一个父类是 Object 这个类，每个类都会继承这个类的方法，包括 equals() 方法\nEquals() 的本质 继承父类的方法后，子类可以对父类的同名方法进行重写，在没有对 equals() 方法重写的情况下，使用 equals 方法判断 2 个对象是否相等与使用 上面所述的用 == 操作符判断结果是一样的，判断的都是这 2 个对象的地址是否相等\n示例代码：\npublic class Test { public static void main(String[] args) { Person jack = new Person(); Person tom = new Person(); Person bob = jack; System.out.println(\u0026#34;jack == tom ? \u0026#34; + (jack.equals(tom))); System.out.println(\u0026#34;jack == bob ? \u0026#34; + (jack.equals(bob))); } } 输出结果：\njack == tom ? false jack == bob ? true 其实看一下 equals() 方法的底层源码，其实使用的就是 == 对 2 个对象进行判断的\npublic boolean equals(Object obj) { return (this == obj); } 重写 equals() 方法 有时候我们不仅是要比较 2 个对象的地址是否一样，还需要判断这 2 个对象的内容是的一样，这个时候就需要对 equals 方法进行重写\n可以对 equals 进行以下的重写\n@Override public boolean equals(Object o) { // 检查是否为同一个对象的引用，如果是直接返回 true if (this == o) { return true; } // 检查是否是同一个类型，如果不是，直接返回 false if (o == null || getClass() != o.getClass()) { return false; } // 将 Object 对象进行转型 Person person = (Person) o; // 判断对象内容是否相等，这里判断的是 name 的内容 return Objects.equals(name, person.name); } 这样对对象的判断就会不一样，这次判断的是对象的内容是否一样\npublic class Test { public static void main(String[] args) { Person jack = new Person(\u0026#34;jack\u0026#34;); Person tom = new Person(\u0026#34;jack\u0026#34;); System.out.println(\u0026#34;jack == tom ? \u0026#34; + (jack.equals(tom))); System.out.println(\u0026#34;jack 地址: \u0026#34; + jack); System.out.println(\u0026#34;tom 地址: \u0026#34; + tom); } } 输出结果：\njack == tom ? true jack 地址: com.mingyu.javalearn.Person@1b2c6ec2 tom 地址: com.mingyu.javalearn.Person@4edde6e5 可以看出，jack 对象实例与 tom 对象实例虽然对象地址不一样，但是由于我们重写了 equals() 方法，使得比较的重点是对象的内容，所以比较的结果是 true\n其他 equals() 重写写法 有许多其他封装好的工具包都对equals()进行了重写\nApache Commons Lang 框架 @Override public boolean equals(Object o) { // 检查是否为同一个对象的引用，如果是直接返回 true if (this == o) { return true; } // 检查是否是同一个类型，如果不是，直接返回 false if (o == null || getClass() != o.getClass()) { return false; } // 将 Object 对象进行转型 Person person = (Person) o; // 判断对象内容是否相等，这里判断的是 name 的内容 return new EqualsBuilder().append(name, person.name).isEquals(); } hashCode()方法 hashCode 也是 Object 类中定义的 方法，也可以比较两个对象是否相等，方法的返回值是调用对象的哈希值，这个哈希值的类型是 int\nhashCode() 的实现 我们看 Object 类的源码，可以发现 hashCode() 这个方法没有具体实现的，因为它是一个本地方法，是使用 C 系语言实现的，这个方法返回的哈希值是通过将对象的内存地址转换为整数得到的。\npublic native int hashCode(); 为什么需要 hashCode() 方法 上述说过的 equals 方法可以判断对象之间是否相等，为什么还需要 hashCode 方法呢？\n在源码的注释中提到了这个原因:\n支持这个方法是为了让哈希表受益，比如java.util.HashMap提供的哈希表 我们知道 HashSet 和 HashMap 等集合类在往集合中添加元素的时候，都会进行一个操作：判断当前需要加到集合的对象是都已经存放在当前集合中，这个时候就涉及到了对象之间的比较\n而 HashSet 和 HashMap 都使用了 hashCode() 方法来计算对象应该存储的位置，因此要将对象添加到这些集合类之前，都需要求出将要存储 key 的hashCode 值\n以下是 HashMap 源码中求 key 的 hashCode 值的方法\nstatic final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h \u0026gt;\u0026gt;\u0026gt; 16); } 那为什么要用 hashCode 方法，而不用 equals 方法呢?\n原因是调用 equals 方法更加耗时\n下面做了的实验\npublic class Test { public static void main(String[] args) { // 开始时间 long stime = System.currentTimeMillis(); // 计算执行时间 Person jack = new Person(); Person tom = new Person(); System.out.println(\u0026#34;jack == tom ? \u0026#34; + (jack.equals(tom))); // 结束时间 long etime = System.currentTimeMillis(); System.out.printf(\u0026#34;equals()执行时长：%d 毫秒.\u0026#34;, (etime - stime)); System.out.println(); System.out.println(\u0026#34;========== 明显的分割线 =========\u0026#34;); // 开始时间 stime = System.currentTimeMillis(); // 计算执行时间 Person mingyu = new Person(); Person bob = new Person(); System.out.println(\u0026#34;mingyu == bob ? \u0026#34; + (mingyu.hashCode() == bob.hashCode())); // 结束时间 etime = System.currentTimeMillis(); System.out.printf(\u0026#34;hashCode()执行时长：%d 毫秒.\u0026#34;, (etime - stime)); } } 输出结果：\njack == tom ? true equals()执行时长：3 毫秒. ========== 明显的分割线 ========= mingyu == bob ? false hashCode()执行时长：0 毫秒. 从输出结果可以看出调用 hashCode 方法几乎不耗时，因为本质上是比较的是 2 个 int 整型值，所以使用 hashCode 方法比较两个对象是很快的\n为什么需要 equals() 方法 既然 hashCode 方法这么快，为什么还需要 equals 方法呢？这是因为 hashCode 方法具有局限性\n局限性：两个对象的 hashCode 值相等并不代表两个对象就相等。\n这是因为 hashCode 值是通过哈希函数计算出来的，一般的计算过程是：通过对数组长度进行取模，这个的数组可以是内存数组、也可是集合数组，由于长度是有限的，就很难避免每次计算出来的哈希值都不一样，就会产出\u0026quot;哈希冲突\u0026quot;，越糟糕的哈希算法越容易产生冲突。\n哈希冲突对于比较两个对象是否相等是有影响的，即两个不同的对象哈希值也可能是一样的。\n所以单单通过 hashCode 方法是不够的，还需要使用 equals 方法进行进一步的判断\nHashSet 在添加元素到集合中的过程中就同时使用到这 2 个方法\n添加元素的步骤： 计算对象的 hashCode 值来判断对象加入的位置 与其他已经加入的对象的 hashCode 值作比较 如果没有一样的 hashCode 值，证明对象没有在当前集合中，因为两个相等的对象的 hashCode 值一定是相等 如果存在一样的 hashCode 值，再通过 equals 方法进行进一步判断 如果对象没有在当前集合中，就把对象存放进集合 这个过程通过先用 hashCode 方法进行判断，拦截了很多已经存在于集合中的元素调用 equals 方法的次数，提高程序执行的速度\nequals 与 hashCode 的关系 在《Effective Java》中写到：\n覆盖 equals 时总要覆盖 hashCode\n在每个重写了 equals 方法的类中，都必须重写 hashCode 方法\n如果只重写了 equals，没有重写 hashCode，当这个类的对象作为元素加到基于散列的集合中就会出现问题\n示例代码：\npublic class Test { public static void main(String[] args) { Person person1 = new Person(\u0026#34;jack\u0026#34;); Person person2 = new Person(\u0026#34;jack\u0026#34;); HashSet\u0026lt;Person\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); set.add(person1); set.add(person2); System.out.println(\u0026#34;person1 equals person2: \u0026#34; + person1.equals(person2)); System.out.println(\u0026#34;person1.hashCode == person2.hashCode: \u0026#34; + (person1.hashCode() == person2.hashCode())); System.out.println(\u0026#34;person1 hashCode: \u0026#34; + person1.hashCode()); System.out.println(\u0026#34;person2 hashCode: \u0026#34; + person2.hashCode()); System.out.println(\u0026#34;set 集合元素个数: \u0026#34; + set.size()); for (Person person : set) { System.out.println(\u0026#34;person: \u0026#34; + person.getName()); } } } 输出结果：\nperson1 equals person2: true person1.hashCode == person2.hashCode: false person1 hashCode: 455896770 person2 hashCode: 1323165413 set 集合元素个数: 2 person: jack person: jack 由于没有重写 hashCode 方法，每次创建对象的时候，都会调用 Object 类的 hashCode 方法，该方法会生成不一样的哈希值\n而前面已经提到过，HashSet 判断一个对象是否存在当前集合，就是根据对象的哈希值判断的，所以会导致 equals 方法与 hashCode 对比的结果不一样，导致 HashSet 存在 2 个我们认为重复的对象\n所以在重写 equals 方法时，一定要同时重写 hashCode 方法\n那该如何重写 hashCode方法？\n重写应该遵循的原则： 如果对象的 equals 方法中比较时用到的信息没有被修改的话，那么多次调用这个对象的 hashCode 方法必须始终返回同一个值 如果 2 个对象 equals 方法比较时相等的，那这 2 个对象的 hashCode 方法都返回同样的结果 public class Person { private String name; @Override public boolean equals(Object o) { // 检查是否为同一个对象的引用，如果是直接返回 true if (this == o) { return true; } // 检查是否是同一个类型，如果不是，直接返回 false if (o == null || getClass() != o.getClass()) { return false; } // 将 Object 对象进行转型 Person person = (Person) o; // 判断对象内容是否相等，这里判断的是 name 的内容 return new EqualsBuilder().append(name, person.name).isEquals(); } @Override public int hashCode() { // 返回的是对 name 这个字段取哈希值 return Objects.hash(name); } } 输出结果：\nperson1 equals person2: true person1.hashCode == person2.hashCode: true person1 hashCode: 3254270 person2 hashCode: 3254270 set 集合元素个数: 1 person: jack 重写后两个对象的 hashCode 值一样，set 集合元素个数也是我们预想中的结果：1 个元素\n参考资料 On Java 中文版 基础卷 深入理解Java核心技术：写给Java工程师的干货笔记（基础篇） Effective Java中文版（第3版） ","permalink":"http://www.lmingyu.tech/posts/tech/java-learn-2/","summary":"\u003cblockquote\u003e\n\u003cp\u003e在写业务代码的时候我们经常需要判断 2 个 Java 对象是否一样，常用判断对象是否相等可以使用 \u003ccode\u003e==\u003c/code\u003e 、equals、hashcode 这 3 个方法，本文试图搞清楚这三者的用法。\u003c/p\u003e\n\u003c/blockquote\u003e","title":"这 2 个对象一样吗"},{"content":" 记录一下自己在学习 MySQL 的一些笔记。\n客户端与服务端相关命令 MySQL 分为客户端和服务端，客户端是发送真实访问的用户，就是需要操作数据库的人，服务端连接 MySQL 数据库，将客户端发送的操作命令发给数据库，然后将操作的结果再返回给用户。\n那为什么客户端不能直接连接数据库呢？\n那是因为一般客户端和 MySQL 数据库不会部署在同一台机器上，这时就不能直接访问数据库，而是必须带着用户名和密码，让服务端与数据库打交道（通常服务端一般会与数据库部署在同一台机器上，可以直接访问）\n启动命令 启动服务端 mysql.server start 指定端口启动 # 这里是大写 P，小写 p 代表密码 mysqld -P3307 启动客户端 mysql -h主机名 -u用户名 -p密码 停止命令 停止服务端 mysql.server stop 停止客户端 # 以下 3 个命令都可以 quit exit \\q 查看版本 mysql -V 存储引擎 查看当前服务器程序所有支持的存储引擎 show engines; 查看当前设置的存储引擎 show variables like \u0026#39;default_storage_engine\u0026#39;; 创建表时指定表的存储引擎 create table 表名 ( 建表语句; ) engine = 存储引擎名称; 修改表的存储引擎 alter table 表名 engine = 存储引擎名称; 修改 MySQL 默认的存储引擎 # 仅对本次启动生效 mysqld --default-storage-engine=MyISAM; ","permalink":"http://www.lmingyu.tech/posts/tech/mysql-learn-1/","summary":"\u003cblockquote\u003e\n\u003cp\u003e记录一下自己在学习 MySQL 的一些笔记。\u003c/p\u003e\n\u003c/blockquote\u003e","title":"MySQL 学习笔记-常用命令"},{"content":" 记录一下自己在学习 Java 的一些笔记。\n重载 重载： 重载指的是方法的重载，重载的特征就是两个或多个方法具有同名。\n经典的重载方法 重载多用于构造器方法，因为构造器作用是初始化构建对象的，构造器的名字必须与类名相同，这就形成经典的无参构造器与有参构造器这一对重载方法。\n下面给出了示例：\n/** * @author mingyu */ public class User { private Integer id; private String userName; // 无参构造器 public User() { } // 单个参数的构造器 public User(Integer id) { this.id = id; } // 全参构造器 public User(Integer id, String userName) { this.id = id; this.userName = userName; } } 为什么需要重载 我们都知道，Java 中最重要的一个概念就是：对象。那方法就是对象的一个个行为。一个对象在做相同名字的行为也可以是在做不同的事情，比如：小明打麻将。\n字面意思：小明在和其他人一起玩麻将这类娱乐活动\n其他意思：小明在 \u0026ldquo;打\u0026rdquo; 一个名字叫 \u0026ldquo;麻将\u0026rdquo; 的人\n所以说，现实生活中语言当中的歧义也会出现在代码里。\n还比如说，一个人在吃东西，我给他什么，他就在吃什么，我给他面条，他的行为就是吃苗条，我给他米饭，他就是在吃米饭，但是他的行为都叫吃东西。\n总结：重载在代码当中是很必要的。\n重载的区分 如果不同的方法都是一个名字，要怎么分辨它们呢？\n分辨重载的重要原则：每个重载的方法必须有独一无二的参数类型列表（即每个方法都有与其他同名方法不同的入参）\n那不同的参数列表，到底哪里不同呢？\n参数类型的不同 public class Test { public static void main(String[] args) { // age 的类型不同可以区分两个同名的方法 getPerson(\u0026#34;mingyu\u0026#34;, 18); getPerson(\u0026#34;mingyu\u0026#34;, \u0026#34;18\u0026#34;); } static void getPerson(String name, int age) { System.out.println(\u0026#34;name: \u0026#34; + name + \u0026#34;, \u0026#34; + \u0026#34;int_age: \u0026#34; + age); } static void getPerson(String name, String age) { System.out.println(\u0026#34;name: \u0026#34; + name + \u0026#34;, \u0026#34; + \u0026#34;String_age: \u0026#34; + age); } } 输出结果：\nname: mingyu, int_age: 18 name: mingyu, String_age: 18 参数顺序的不同 虽然参数顺序不同可以区分同名的重载方法，但是不推荐使用这种使用方式进行区分，因为这样写代码很难维护\npublic class Test { public static void main(String[] args) { getPerson(\u0026#34;mingyu\u0026#34;, 18); getPerson(18,\u0026#34;mingyu\u0026#34;); } static void getPerson(String name, int age) { System.out.println(\u0026#34;name: \u0026#34; + name + \u0026#34;, \u0026#34; + \u0026#34;behind_age: \u0026#34; + age); } static void getPerson(int age, String name) { System.out.println(\u0026#34;name: \u0026#34; + name + \u0026#34;, \u0026#34; + \u0026#34;first_age: \u0026#34; + age); } } 输出结果：\nname: mingyu, behind_age: 18 name: mingyu, first_age: 18 返回值区分重载方法 除了参数列表的类型、顺序可以区分方法外，我们能否用方法的返回值来区分呢？\n答案是不行的，下面给出了例子。\nvoid f() {} int f() { return 1; } 当我们只想调用 f() 方法，但不需要该方法的返回值（如 System.out.println 方法），这时如果只是调用方法 f()，Java 是无法区分我们需要调用的是哪个方法的。\n基本类型的重载 对于只有基本类型不同的重载方法，会出现基本类型可以从小类型自动提升到较大类型的情况\npublic class Test { public static void main(String[] args) { int x = 5; checkBasicTypes(x); } static void checkBasicTypes(long x) { System.out.println(\u0026#34;Type long: \u0026#34; + x); } static void checkBasicTypes(float x) { System.out.println(\u0026#34;Type float: \u0026#34; + x); } static void checkBasicTypes(double x) { System.out.println(\u0026#34;Type double: \u0026#34; + x); } } 输出结果：\nType long: 5 变量 x 为 int 类型，但是 checkBasicTypes() 方法并没有 int 类型的入参，当程序运行时，会找到类型比 int 类型大的方法进行调用，即传入数据类型小于方法的参数类型，传入的数据类型会自动被提升。（ int -\u0026gt; long）\n重写 重写一般出现在父子类关系之间，父类与子类有两个名称与参数列表都相同的方法，由于它们具有相同的方法名称，所以在方法调用的时候，子类的方法会覆盖同名的父类方法。\n下面是重写的一个例子\npublic class Test { public static void main(String[] args) { Animal animal = new Dog(); animal.say(); } } class Animal { public void say() { System.out.println(\u0026#34;I\u0026#39;m animal.\u0026#34;); } } class Dog extends Animal { @Override public void say() { System.out.println(\u0026#34;I\u0026#39;m Dog.\u0026#34;); } public void eat() { System.out.println(\u0026#34;Dog like eat meat.\u0026#34;); } } 输出结果：\nI\u0026#39;m Dog. 上面的例子中，父类与子类都定义了 say() 方法，实际上称之为子类重写了父类的 say()方法。\n重写方法之后，当我们调用子类对象的 say() 方法，尽管 Dog 对象的类型是 Animal ，Java 依然会调用 Dog 的 say() 方法，因为子类的方法会覆盖同名的父类方法。\n重写的原则 如果需要重写方法，需要满足里式替换原则：\n子类方法的访问权限必须大于等于父类方法 如父类方法修饰符为 protected，那子类方法的修饰符只能是 protected 或 public 子类方法的返回类型必须是父类方法返回类型或为其子类型。 如 B extends A : 父方法返回类型为 A，那么子类方法可以返回 A类型，也可以是 B 类型 子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。 @Override 注解 @Override 注解并不是 Java 中的关键字，但可以当做关键字一样使用，如果在重写方法上加上这个注解，编译器就会帮助你检查是否满足上面的三个限制条件，检测这个重写方法是否合法。有时候还可以有效的防止意外重载。\n参考资料 On Java 中文版 基础卷 深入理解Java核心技术：写给Java工程师的干货笔记（基础篇） ","permalink":"http://www.lmingyu.tech/posts/tech/java%E5%9F%BA%E7%A1%80-1/","summary":"\u003cblockquote\u003e\n\u003cp\u003e记录一下自己在学习 Java 的一些笔记。\u003c/p\u003e\n\u003c/blockquote\u003e","title":"重载与重写"},{"content":" 用好系列就是记录自己日常如何使用好软件工具，此文为用好系列-IDEA之插件篇，用于记录自己日常开发编程时IDEA常用的插件，此系列会持续更新。本文只记录插件本身，不记录插件使用方法，若记录使用方法，会导致内容长度过长，不方便阅览，使用方法可自行谷歌学习。\n外观类 外观是第一生产力\nNyan Progress Bar 让你 IDEA 里面的进度条变得更可爱\n插件地址\nXcode-Dark Theme 换过很多的主题，还是这个主题用的最舒服\n插件地址\nRainbow Brackets 给你的括号加上不同颜色，加以区分\n插件地址 CodeGlance Pro 给你的代码增加缩略图，可以快速查找代码的位置\n插件地址\nExtra ToolWindow Colorful Icons 丰富你的工具窗口图标\n插件地址\nExtra Icons 丰富文件夹图标，这个是需要 IDEA 商业版才能使用\n插件地址\n工具类 Auto filling Java call arguments 在创建方法或构造方法会自动填充方法的所有参数\n使用方法：alt + Enter\n插件地址\nGenerateAllSetter 一键调用一个对象的所有的set方法，在给实体类设置值时很实用\n使用方法：alt + Enter\n插件地址\nGrep Console 通过expression表达式过滤日志、给不同级别的日志加上你想要的颜色。\n插件地址\nGsonFormatPlus 可以快速将 Json 转换为 Java 的类\n插件地址\nJRebel and XRebel 一款热部署 JVM 插件，通过跳过耗时的构建和重新部署步骤，简化了 Java 应用程序本地调试开发，这插件需要激活才能使用，可自行谷歌搜索一下\n插件地址\nMaven Helper 可以使用 Maven Helper 插件的 Dependency Analyzer 来分析工程的多级依赖关系，解决依赖冲突问题，在项目的 pom.xml文件下方打开 Dependency Analyzer 进行分析\n插件地址\nMyBatisX MybatisX 是一款基于 IDEA 的快速开发插件，包括以下比较好用的功能如：XML 跳转、自动生成代码（根据数据库表结构生成实体类和一些基本的mapper）、重置模板、JPA 提示等\n插件地址\n插件使用介绍\nString Manipulation 主要可以用于字符串处理：大小写切换、排序、转义、格式调整（对齐、删除空行）、加解密等。使用 Alt + M 快捷键快速操作，功能十分强大。\n插件地址\nTranslation 使用过笔记好用的翻译，是阅读源码的一个利器，个人使用的是阿里的翻译引擎，使用阿里开发账号即可激活\n插件地址\n锦上添花类 Alibaba Java Coding Guidelines(XenoAmess TPM) 是根据阿里的 Java 开发手册生成的一个代码规范插件，帮助我们写出更规范的代码\n插件地址\nSonarLint 同样是一个代码检插件，经常会提示一些更好的代码写法，推荐使用。\n插件地址\nSpotBugs 会帮助你找出代码中一些潜在的代码 BUG，但是它分析出来的也不能全信，还是要自己分析\n插件地址\nAlibaba Cloud AI Coding Assistant 阿里出的代码推荐插件，根据你敲出的几个字母给你推荐你可能需要的代码，最喜欢它的一个功能是代码文档搜索，它可以帮你找到已经开源的一些 API 接口的写法。\n像这种 AI 推荐代码的插件还有很多，AiXcoder Code Completer、Tabnine AI Code Completion- JS Java Python TS Rust Go PHP \u0026amp; More，选择自己喜欢就可以，但是不要沉迷代码工具，这些工具只能辅助，代码还是得自己写。\n插件地址\n取舍与优化 插件虽好，但不要贪多哦\n当你下载了很多插件使用的时候，难免会对 IDEA 软件运行和代码编译会造成影响，这时候就要进行适当的取舍和优化\n我们可以用 IDEA 本身有的功能分析每个插件对项目启动的影响，对于不使用的插件可以进行禁用。\nHelp -\u0026gt; Diagnostic Tools -\u0026gt; Analyze Plugin Startup Performance\n可以适当提供 IDEA 软件使用内存的上限，设置完之后重启即可生效。\nHelp -\u0026gt; Diagnostic Tools -\u0026gt; Analyze Plugin Startup Performance\n","permalink":"http://www.lmingyu.tech/posts/tech/%E7%94%A8%E5%A5%BDidea-1/","summary":"\u003cblockquote\u003e\n\u003cp\u003e用好系列就是记录自己日常如何使用好软件工具，此文为用好系列-IDEA之插件篇，用于记录自己日常开发编程时IDEA常用的插件，此系列会持续更新。本文只记录插件本身，不记录插件使用方法，若记录使用方法，会导致内容长度过长，不方便阅览，使用方法可自行谷歌学习。\u003c/p\u003e\n\u003c/blockquote\u003e","title":"用好系列-IDEA之插件篇"},{"content":" 做事总是三分钟热度，是一种病吗\n​\t我往往在最近一段某一段时间都会有一些工作以外想做的东西，学一门外语、学会做菜、学吉他、学一门技术等等。一开始会兴致勃勃的查教程、查攻略，看各种视频，问他人推荐该怎样开始会少走一些弯路\u0026hellip; \u0026hellip;\n经过一点时间收集之后，等我认为所有事前准备都 OK 的时候，完事具备只欠开始时，我却犹豫了。又或者我刚开始这件事情的时候遇到很多需要自己独自解决的事情，众多的困难如拦路虎一般挡住我前进的道路。很多事情出发点是好的，对自己有益处的，但是就是在开始的时候会给自己的信心浇上一盆冷水，而且这种情况经常发生。\n在背单词的时候，永远只能背到 a 字母开头的；\n在学一门技术的时候，往往只能看到入门的地方就没有了下文；\n健身持续了几周之后，然后因为难以持续大肚子它又回来了；\n刷算法题，刷的那几道熟悉的题都滚瓜烂熟了，但新题往往觉得很难，就不想刷了\n\u0026hellip; \u0026hellip;\n我尝试分析一下原因：每件事情我一开始就在自己内心定下了一个很大的目标，每次完成这件事情之后，不仅身体觉得很累，心也很累，到下次开始做这件事的时候，身心都感到了抗拒，最后便无疾而终。\n最近看到刘未鹏写的《暗时间》第 2 版，这里面有给到我启发，做一件事，最难的是开始并持续下去，过早的退出，是一切失败的根源。\n\u003c!DOCTYPE HTML\u003e 保持做一件事情，兴趣是很关键的一件因素。但是对我们这种好像对什么事情都提不起兴趣的人该怎么办呢？\n我觉得，让自己保持在一个舒服的状态才能一直做一件事情，想想我们每天都做过一些不是生活必须的事情，是不是都让我们无感、甚至很舒服，至少不会让自己感到难受，比如：\n吃完饭会习惯散步走一圈\n每天习惯性看一下新闻，关心一下今天都发生什么事情\n每天做一次核酸（我是无感的，但是有些人就是觉得核酸对他生活造成了影响）\n这些日常都会做的事情，不是自己兴趣所在，但为什么能持续地做呢，我总结就是：这些事情对你的生活不造成侵入，让你保持在一个还比较舒服的状态。基于这个结论，我可以以一个比较舒服的状态去做每一件事情，每天只背 5 个单词，每天只刷一道题，每周学做一道菜\u0026hellip;\n但是这样做事情，效率不是很慢吗？但其实认真想想，这些背单词、学吉他、学技术，每天学 10 分钟，从几年前开始，到现在为止，我已经可以把这些事情完成的很好了。\n所以，从量少入手，让巨浪变成浪花。\n","permalink":"http://www.lmingyu.tech/posts/life/1/","summary":"\u003cblockquote\u003e\n\u003cp\u003e做事总是三分钟热度，是一种病吗\u003c/p\u003e\n\u003c/blockquote\u003e","title":"让自己舒服才能持续下去"},{"content":" 常用系列就是记录自己编程常用的东西，此文为常用系列第 2 篇，用于记录自己日常常用的 Git 命令，以便需要时查找。Git 尽管提供了 GUI 界面进行操作，但是我觉得 Git 的 GUI 软件有很多，但是掌握最常用的命令还是一个合格的程序员应该做的，毕竟命令到哪里都一样，但 GUI 软件万一哪一天用不了了呢🐶，而且命令行模式可以执行 Git 的所有命令。\nGit 最基本的操作 文件从本地到仓库流程：以下记录一下用哪些命令可以将一个文件从自己的本地推送到远端的仓库，我把这称为基本操作\n安装 Git 如果想要在 Mac 电脑安装 Git，只需要输入查询 git 版本的命令就会提示你安装（如果你之前没装过的话）\ngit --version 配置用户信息 安装完 git 之后对 git 的环境进行配置，这些配置在每台计算机只需要配置一次，当然配置完以后也可以修改，git 最常用的配置就是对用户名和邮箱地址的设置，--global代表对系统上所有仓库都生效。\n# 设置用户签名，可在 .gitconfig 文件中查看 git config --global user.name \u0026lt;用户名\u0026gt; # 设置用户邮箱，可在 .gitconfig 文件中查看 git config --global user.email \u0026lt;注册git仓库邮箱\u0026gt; 获取 Git 仓库 通常获取仓库有两种方式：\n将本地目录转换为 Git 仓库 从别的地方复制一个仓库到你的本地 在已存在目录中初始化仓库 git init 这个命令会在当前目录下创建一个.git的目录，目录中包括初始化仓库的所有文件\n克隆仓库 git clone https://github.com/libgit2/libgit2 这个命令会从远端 GitHub 的 libgit2 仓库拉取所有东西到你当前目录\n记录文件状态 文件的状态有 2 种：已被跟踪、未被跟踪，跟踪的意思是现在 git 可以记录这个文件发生的所有变化（被修改、被删除、重命名）\n查询文件状态 git status # 简洁输出文件状态，A-先添加到暂存区、M-修改过的文件、D-删掉的文件、R-重命名的文件、??-未被跟踪的文件 git status -s 跟踪新文件 # 使用以下命令之后，一般都会再使用 git status 查看文件是否被跟踪 git add \u0026lt;文件名\u0026gt; # 将所有待加入暂存区的文件加入暂存区 git add . 使用该命令之后，文件就会被放入 git 的暂存区，暂存区里面的文件都是即将要推送到远端仓库的候选者。\n对比已暂存的文件与未暂存文件之间的区别 通常我们修改文件过多时就会容易忘记某个文件修改过的内容，这个时候就需要查看我们做过哪些修改就可以使用diff命令\n# 文件需在暂存区，即被跟踪才能使用本命令 git diff \u0026lt;文件名\u0026gt; 如果你想对比暂存区里的文件与上次提交时文件的区别，就可以使用以下命令\ngit diff --cached 提交更新 如果你的暂存区里面已经包括你本次想要提交的文件，就可以通过commit命令对文件的修改进行提交\n# 每次commit都会清空暂存区 git commit -m \u0026#34;\u0026lt;双引号里面填的是本次提交文件的一个描述信息\u0026gt;\u0026#34; 推送文件到远端 添加远端仓库 如果你不是从远端仓库克隆 clone 的文件，而是自己在本地自己创建的 git 仓库，就需要在向远端仓库推送之前加上你要推送的仓库\ngit remote add https://github.com/paulboone/ticgit 推送 git push origin master 这个命令代表着将 master 分支的代码推送到远端的 origin 服务器\n到此一个文件从创建到最终同步到远端仓库的这个过程就圆满完成。\n下面就记录一下在使用 git 的过程中遇到一些情况该使用哪些命令。\n查询 这里的记录是使用 git 场景下各种需要查的情况\n查提交历史 整个项目历史提交记录 git log commit ca82a6dff817ec66f44342007202690a93763949 Author: Scott Chacon \u0026lt;schacon@gee-mail.com\u0026gt; Date: Mon Mar 17 21:52:11 2008 -0700 changed the version number commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 Author: Scott Chacon \u0026lt;schacon@gee-mail.com\u0026gt; Date: Sat Mar 15 16:40:33 2008 -0700 removed unnecessary test # 以一行的形式展示过往所有的提交 git log --pretty=oneline # 分支提交图 git log --graph git log --graph --pretty=oneline --abbrev-commit 输出的内容依次是：\n每个提交的 SHA-1 校验和 提交人的名字 邮箱地址 提交时间 提交说明 文件的历史提交记录 查看单个文件每次的提交记录\ngit log -p \u0026lt;文件名\u0026gt; # 只显示最近 2 次提交 git log -p -2 \u0026lt;文件名\u0026gt; 每一行的提交记录 能显示任何文件中每行最后一次修改的提交记录\ngit blame \u0026lt;文件名\u0026gt; # 限定显示哪一行 git blame -L 69,82 \u0026lt;文件名\u0026gt; 查找BUG 很多时候，当前分支出现问题了，但不清楚哪里出现了问题，就可以使用git bisect命令查找哪一次代码提交引入了错误\n这个命令使用的原理是二分查找的原理：\n通过二分【代码是没问题的提交 ~ 当前有问题的分支】这个范围找到可能有问题的那一次提交\ngit bisect start命令启动查错，它的格式如下:\n$ git bisect start [终点] [起点] 终点是最近的提交，起点是更久以前的提交。它们之间的这段历史，就是差错的范围\n当不清楚哪个起点提交时没问题的时候可以选择最开始的分支\n# 终点是当期分支 HEAD，起点是第一次提交 4d83cf git bisect start HEAD 4d83cf 执行上面的命令以后，当前的代码就会切换到这段范围当中中间的那一次提交\n然后你就可以对当前代码进行测试，如果是没有问题就执行以下命令对本次提交进行标识\ngit bisect good 如果没问题就意味着错误是在代码历史的后半段引入的。执行上面的命令，Git 就自动切换到后半段的中点\n然后再进行测试，如果是有问题的就标识这个提交是有问题的\ngit bisect bad 到这里不是就结束了哦，有问题只是这次有问题，但我们需要找到第一次有问题的提交\n接下来，不断重复这个过程，直到成功找到出问题的那一次提交为止。这时，Git 会给出如下的提示。\nb47892 is the first bad commit 然后就可以去分析这次都提交了哪些文件，从而分析错误是什么原因引起的\n注意：代码缺陷需要自己去判断的，git 是没办法帮你分析出哪里有问题\n然后，使用git bisect reset命令，退出查错，回到最近一次的代码提交。\n查找内容 由于 git 与 Linux命令一样，同样可以与 grep搭配使用\ngit grep -n \u0026#34;\u0026#34; 撤销 我们在操作 Git 的时候难免会出现出错的时候，修改错误的办法一般不是重新修改就是回退到没问题的时候\n文件的撤销 将文件尚未加入暂存区的修改全部撤销 # -- 很重要，没有--，就变成了“切换到另一个分支”的命令 git checkout -- \u0026lt;文件名\u0026gt; # 恢复暂存区的所有文件到工作区 git checkout . # 恢复 commit 的指定文件到暂存区和工作区 git checkout [commit] [file] 将工作区相对于暂存区的修改撤销，如果暂存区没有对应的文件则回退到HEAD指向的版本 git restore \u0026lt;文件名\u0026gt; 将暂存区的文件修改撤销掉（unstage），重新放回工作区 git reset HEAD \u0026lt;文件名\u0026gt; 版本的撤销 常用于提交版本之后，远端发生冲突无法 merge 分支，用git resrt回退版本处理完冲突后再进行推送\n# 将commit过的代码库回滚到上一个版本 git reset --hard HEAD^ 或 git reset --hard HEAD~ # 往上回滚两次版本，以此类推 git reset --hard HEAD^^： # 往上回滚100个版本 git reset --hard HEAD~100： # 回滚到某一特定版本，版本号为前7位，使用git reflog可以查出 git reset --hard 版本号： 分支操作 分支基本操作 # 列出所有本地分支，当前分支前面会标一个*号 $ git branch # 列出所有远程分支 $ git branch -r # 列出所有本地分支和远程分支，并详细展示分支信息 $ git branch -av # 新建一个分支，并切换到该分支 $ git checkout -b [branch] # 切换到指定分支，并更新工作区 $ git checkout [branch-name] # 切换到上一个分支 $ git checkout - # 删除分支 $ git branch -d [branch-name] merge 用于合并两个分支\n# 合并指定分支到当前分支 $ git merge [branch] rebase 也用于分支合并\n合并分支的操作与merge基本一样，\n# 合并指定分支到当前分支 git rebase [branch] 如果git rebase遇到冲突:\n第一步手动解决冲突，然后把新修改的文件加入暂存区 git add . 之后并不需要 git commit，而是直接运行git rebase --continue 至于git merge 与 git rebase有什么区别呢？\ngit merge合并完之后会显示出来合并之前的分支，而git rebase合并之后看起来并不会有之前合并的分支记录 分支合并的顺序也不一样 详细可以看一下这个博客 git merge 和 git rebase 小结\ncherry-pick 合并指定提交到当前分支\n# 选择一个 commit，合并进当前分支 git cherry-pick [commit] # 合并多次提交到当前分支 git cherry-pick \u0026lt;HashA\u0026gt; \u0026lt;HashB\u0026gt; # 合并联系一段的提交，A 提交必须早于 B，提交 A 不会包含本次提交 git cherry-pick A..B # 合并联系一段的提交，A 提交必须早于 B，本次提交包含提交 A git cherry-pick A^..B 如果 cherry-pick过程中发送冲突，则在手动处理完冲突之后使用--continue命令让过程继续\n解决代码冲突后，将修改的文件重新加入暂存区git add . 使用下面的命令，让 Cherry pick 过程继续执行。 git cherry-pick --continue 参考资料 Git 官网\ngit bisect 命令教程\ngit cherry-pick 教程\nGit 教程-开发者手册\n一个一步一步显示 git 命令的网站\n","permalink":"http://www.lmingyu.tech/posts/tech/git%E5%91%BD%E4%BB%A4/","summary":"\u003cblockquote\u003e\n\u003cp\u003e常用系列就是记录自己编程常用的东西，此文为常用系列第 2 篇，用于记录自己日常常用的 Git 命令，以便需要时查找。Git 尽管提供了 GUI 界面进行操作，但是我觉得 Git 的 GUI 软件有很多，但是掌握最常用的命令还是一个合格的程序员应该做的，毕竟命令到哪里都一样，但 GUI 软件万一哪一天用不了了呢🐶，而且命令行模式可以执行 Git 的\u003cstrong\u003e所有命令\u003c/strong\u003e。\u003c/p\u003e\n\u003c/blockquote\u003e","title":"常用系列-Git命令"},{"content":" 本文记录如何使用 Surge 将家中的 Mac 电脑成为家中其他设备科学上网的中转站。\n前情提要 今年 618 大促入手人生第一台掌机游戏机 Nintendo Switch OLED 版（日版），Switch 游戏可以从eshop 中下载，但是国内直接访问下载 eshop 中的游戏速度可以说是龟速。得知 Switch 中 eshop 需要和 Steam 一样开启游戏加速器才能正常使用。但是 UU 加速器使用包年需要 283 RMB，就不舍得（对，我就是那种买贵东西不眨眼，但是买便宜附属品时斤斤计较的人🙄）。\n我记起来之前看过其他人用 Surge 把 Mac 当中代理转发让 Apple TV 可以顺利地访问（科学上网），我到网上查找教程，果然真的可以，于是就有了这篇教程，也是做一个记录，以便以后翻阅。\n前期环境准备 Surge for Mac （通过 Mac 电脑作为中间商为其他设备作为代理转发） Mac Studio （接着网线的，配置好之后是不能关机的，我试过 Mac 电脑休眠之后 Surge 软件是会自动退出的，所以需要保持电脑不要休眠，如果休眠了需要重新开启才能继续使用） M1 Max 运存：64 G 系统：masOS Monterey 12.4 机场订阅地址（没有的话需要自己找一下😂，科学上网必备） 以下教程默认已经准备好以上的 3 个条件\nSurge Surge 介绍 总览 Surge 是一个网络开发和代理工具。他是为开发者打造的工具，所以使用时需要具备一定的专业知识。\n以下四种是 Surge 的核心工作流。\n接管：接管设备发起的网络连接。Surge 支持代理服务器和虚拟网卡两种接管模式。 处理：可以修改已经接管的网络请求和响应。包括 URL 重定向、本地文件映射、使用 JavaScript 自定义修改等多种方法。 转发：可以将已接管的网络请求转发到其他代理服务器。这可以是全局转发，也可以通过灵活的规则系统来确定出站策略。 拦截：可以拦截并保存网络请求和响应的数据，也可以通过 MITM 解密 HTTPS 流量。 我们这里主要使用的是转发\n特点 我使用 Surge 这个软件主要是被它这几个特点吸引的：\n高性能、稳定、高效率：Surge 可以在耗费极少资源并且保持高稳定性的前提下轻松处理网络数据，配合 M1 芯片更加节能和稳定 增强模式：Surge 会设置一个虚拟网络去接管所有的网络请求，尤其是那些对 Web 代理支持不好的软件。 网关模式：Surge Mac 可以当做三层网关去处理同网络下其他设备的网络请求。（简单来说就可以当做一个路由器，成为家中网络枢纽） Surge 下载与购买 下载 Surge for Mac 可以直接在 Surge 官网下载，我下载的版本是最新版，Surge 4.6.1 (1718) ，下载完之后是一个压缩包，解压之后把 app 拖到应用程序中即可打开使用了。\n但是下载之后并不能直接科学上网的，还是需要花钱进行购买，到官网进行授权购买，购买 1 台设备授权 49.99 美刀，3 台设备授权 69.99 美刀，5 台设备授权 99.99 美刀，支持支付宝付款，这里我买的是 3 台设备授权（我是想在过年回家也可以给家里也弄一个就买的3台），实花 471.13 RMB （根据当时汇率波动，心疼啊），可以根据个人需求进行购买，至少购买 1 台。\n购买之后就可以根据购买时的邮箱地址和购买之后给你邮箱发的激活码对 Surge 进行激活。\nSurge 接管 Mac 网络 接下来就可以让 Surge 接管 Mac 电脑的网络了（让 Mac 可以科学上网），这时候就需要你有机场的订阅地址了。\n往 Surge 中添加配置文件\n这里使用的是从 URL 安装配置文件，你也可以通过文件进行导入或者自己手动添加配置。\n如果你订阅的机场是直接有 Surge 的订阅地址可以直接添加，如果没有，但是有v2ray、ss 、trojan 的订阅也是可以的，通过第三方订阅转换生成 Surge 可以识别的 URL 。\n选择基础模式，如果你想自定义你想要的特定节点可以选择进阶模式 在订阅链接中粘贴上你订阅机场的订阅地址 在客户端下拉框中选择 Surge4 点击红色生成订阅链接就可以生成定制订阅 URL，点击复制 打开 Surge 主界面左下角更多，选择设置中的配置\n选择从 URL 安装配置文件\n粘贴你刚才由第三方生成的配置文件订阅地址，然后选择完成，等待一会 Surge 就会对规则策略进行导入\n等 Surge 识别完成之后会出现一个新的托管配置，选中这个新的配置，并点击右下角应用\n回到 Surge 主界面，选中代理下的策略，选择 规则判定 ，这时检测一下科学上网是否成功了，如果不行，点击标签栏的 Surge 检查一下是否勾选了 设置为系统代理 和 增强模式，没有勾选可以勾选上，并重启一下 Surge\n到此你的 Mac 就可以愉快地上网了\n让 Mac 成为家中网络枢纽 上面的步骤已经可以让 Mac 电脑愉快地上网了，但是独乐了不如众乐乐，那怎么让家里其他设备也可以愉快地上网呢？\n这里就需要用到 Surge 的 DHCP 服务器这个功能了，也就是上面介绍过的网关模式。\n设置电脑 IP 为静态IP 打开 系统偏好设置-网络，选择以太网（也就是网线接口） 配置 IPv4 选择 使用 DHCP（手动设定地址） 我的路由器是 192.168.1.1 所以 IP 地址我就填 192.168.1.2，只用修改最后一位在 2-225 之间就行。（如果你的路由器是 192.168.0.1 你的 IP 地址就可以填 192.168.0.2，以此类推） 随后选择 应用 注意：这里设置之前先把 Surge 设置为系统代理先关掉，开启会影响后面 ip 地址设置，建议先关掉，后面设置完之后再开启。\n关闭路由器 DHCP 登录到你们家的路由器管理后台，在管理页面中找到 DHCP 服务器设置，把路由器的 DHCP 关掉（一般路由器都会有这个选项）\n打开 Surge DHCP 选项 在Surge左侧 设备 里，点开后最下面有 DHCP 服务器 开关，点开后选择下一步。\n插网线的选择 Ethernet ，点击下一步。\nSurge 会检测当前网络环境是否有 DHCP 设置，如果上面你正确关闭了 路由器 DHCP 这里应该能直接生成配置\n选择 Surge 默认的设置点击完成即可，如果你发现这里路由地址为空（我一开始在这里卡了很久，后面发现选错了网络设备，选成了Ethernet Adapter (en6)），你就要检查一下哪里步骤出错了\n启动完 DHCP 服务器之后可以看到设备列表没有任何设备，这时需要重启一下路由器或者让你想使用的设备重新连接一下wifi，就可以在新增设备中看到\n添加设备成员 想要科学上网的设备可以右键选择设备名，然后选择 使用 Surge 作为网关，然后设备重新连接wifi或者关闭路由器 wifi 再打开即可。\n没连接上会显示等待连接，这里建议把设置固定 IP 地址也选上，这时官网推荐的做法，方便以后设备管理和连接。\n苹果手机和平板，由于注重隐私的原因会默认在连接 Wifi 的时候选上使用私有无线局域网地址进行连接（使用私有地址有助于减少不同无线局域网对 iPhone 的跟踪），这里需要把这个选项关掉重新连接 wifi 才能让 Surge 识别出你的设备。\n如果不清楚 IP 地址具体对应哪台设备，可以到路由器管理后台查看或者根据此 IP 的制造商进行推断。\n最后推荐将设备连接Wifi的IPV4地址改为手动，因为你如果你启用了自动DHCP的话，有可能下次连接这个WIFI时IP地址就会改变，如果连接失败，可以按照以下的配置将IPV4地址改为手动即可。\n至此，家里的想要一起科学上网的设备都可以通过 Mac 电脑这个网络枢纽一起愉快玩耍了！\n特殊情况 一开始使用的时候，我遇到过用surge作为网关的 Mac 可以打开网页的 youtube 视频并且能观看，但是家里其他设备通过wifi连接的缺不能访问 google，检查一下是可以打开 youtube App，但是只能看到视频的缩略图，进一步点击打开视频观看，却始终是 loading状态，无法观看。奇怪的是可以打开Netflix，正常看剧。\n这种情况查找到解决的办法是，在你需要访问 YouTube 的设备上把连接的 wifi 的 DNS配置修改一下，从自动改为手动，并添加一个 DNS 服务器 192.0.2.2\n至于为什么设置为这个DNS地址我也不是很清楚，只知道手册上是这样写的🐶，这样就把 YouTube 不能访问的问题就解决了！\n总结 以后有其他设备想要愉快上网，都可以通过这台被 Surge 附魔的 Mac 电脑作为转发代理，省下了加速器的年费，还比加速器好使，覆盖范围更广，但需要的是这台 Mac 电脑要一直开着，不然家里其他的设备都上不了网。\n这篇文章只是简单使用了 Surge 的简单功能（规则访问策略并没有定制化），用户还可以对 Surge 进行很多定制化的改造，这些更深入的功能就等以后慢慢发掘吧，先去愉快地玩我新到的 Switch 啦，有什么好玩的游戏，欢迎推荐！\n参考资料 Surge 把你的 Mac 变成最强路由器 Surge 使用手册 Surge 教程 Surge 论坛 家庭网络部署心得 ","permalink":"http://www.lmingyu.tech/posts/tech/%E5%88%A9%E7%94%A8surge%E6%8A%8Amac%E5%8F%98%E6%88%90%E5%AE%B6%E4%B8%AD%E7%BD%91%E7%BB%9C%E6%9E%A2%E7%BA%BD/","summary":"\u003cblockquote\u003e\n\u003cp\u003e本文记录如何使用 Surge 将家中的 Mac 电脑成为家中其他设备科学上网的中转站。\u003c/p\u003e\n\u003c/blockquote\u003e","title":"利用Surge把Mac变成家中网络枢纽"},{"content":" 常用系列就是记录自己编程常用的东西，此文为常用系列第 1 篇，用于记录自己日常开发编程时常用的 Linux 命令，以便需要时查找。\n文件操作命令 查看目录 ls # 回到上一个目录 cd - # 显示所有文件 ls -a # 显示目录中的文件按照修改时间排序 ls -lht tree 展示当前目录的文件结构\n# 展示当前目录的文件结构 tree -FC / -a：展示隐藏文件 -C: 颜色显示 -L 2: 只显示2层 -F: 显示目录后面的\\；显示可执行文件*；功能类似ls -F 修改文件权限 # 修改文件权限 chmod # 给xxx添加可写权限，常用于给需要运行的脚本赋予权限 chmod +x xxx # 给xxx添加可读权限 chmod +r xxx # 将xxx的权限改成777 ，所有人都对这个文件可读可写可运行 chmod 777 xxx # 递归修改整个文件夹的权限 chmod 777 xxx -R 查看文件内容 more # 浏览文件内容 more \u0026lt;filename\u0026gt; 回车：下一行 空格：下一页 # 页面进度增加36% b：上一页 q：退出 less # 与more类似，功能更全 less 回车：下一行 y：上一行 Page Down：下一页 Page Up：上一页 q：退出 tail # 展示文件末尾3行内容 tail -3 \u0026lt;filename\u0026gt; # 常用于观察日志写入过程 tail -f -n 1000 \u0026lt;filename\u0026gt; 管道相关 wc # 输出结果依次为统计行数、单词数、字节数 wc wc -l：统计行数 wc -w：统计单词数 wc -c：统计字节数 grep # 在文件中过滤出给定的match_patten grep match_patten \u0026lt;file\u0026gt; 常用参数 -c 统计文件中包含文本的次数 -n 打印匹配的行号 -i 搜索时忽略大小写 # 从stdin中读入若干行数据，如果某行中包含xxx，则输出该行。--color代表高亮显示 grep xxx --color # 在多级目录中对文本递归搜索(程序员搜代码的最爱） grep \u0026#34;class\u0026#34; . -R -n # 找到使用过的命令 history | grep \u0026lt;命令\u0026gt; xargs xargs 能够将输入数据转化为特定命令的命令行参数；这样，可以配合很多命令来组合使用。比如 grep，find；\nxargs参数说明 -d 定义定界符 （默认为空格 多行的定界符为 n） -n 指定输出为多行 -I {} 指定替换字符串，这个字符串在xargs扩展时会被替换掉,用于待执行的命令需要多个参数时 -0：指定0为输入定界符 将多行输出转化为单行输出 cat file.txt| xargs 将单行转化为多行输出，-n：指定每行显示的字段数 cat single.txt | xargs -n 3 cat file.txt | xargs -I {} ./command.sh -p {} -1 cut 用于从每行中删除部分内容\n#分割一行内容，从stdin中读入多行数据 示例： echo $PATH | cut -d \u0026#39;:\u0026#39; -f 3,5 输出PATH用:分割后第3、5列数据 echo $PATH | cut -d \u0026#39;:\u0026#39; -f 3-5 输出PATH用:分割后第3-5列数据 echo $PATH | cut -c 3,5 输出PATH的第3、5个字符 echo $PATH | cut -c 3-5 输出PATH的第3-5个字符 查找文件 locate 按照路径名查找文件，查找的范围在 /var/lib/mlocate/ 这个数据库中，存储在内存中，每天更新一次，所以无法用 locate 搜索新建的文件，可以使用 updatedb 来立即更新数据库。\n系统如果没有自带locate命令，可以使用yum install mlocate -y安装，安装结束执行updatedb命令\n# 查找名称含有 zip 文件 lcoate zip find命令 以文件名查找文件\n# 搜索某个文件路径下的所有*.py文件 find /path/to/directory/ -name \u0026#39;*.py\u0026#39; # 忽略大小写搜索 find /home -iname \u0026#34;*.txt\u0026#34; # 当前目录及子目录下查找所有以.txt 和.pdf 结尾的文件 find . -name \u0026#34;*.txt\u0026#34; -o -name \u0026#34;*.pdf\u0026#34; # 查看当前目录下文件个数 find ./ | wc -l # 按类型搜索，只列出所有目录，-type f 文件 / l 符号链接 / d 目录 find . -type d -print # 限定查找文件的大小，+1M 代表查找大于 1M 的文件 find ./ -type f -name \u0026#34;*.py\u0026#34; -size +1M # 删除符合条件的文件，下面的命令能够当前删除当前目录下后缀为 .bak 的文件 find ./ -type f -name \u0026#34;*.bak\u0026#34; -delete sed文本替换 sed一般用于对文本内容做替换，操作时是逐行操作\nsed的基本工作方式是：\n将文件以行为单位读取到内存（这个内存也叫模式空间） 使用sed的每个脚本对该行进行操作 处理完成后输出该行 格式\nsed ‘操作命令’ 一个或多个文件\nsed的替换命令s: sed \u0026#39;s/旧的字符串/新的字符串/\u0026#39; 文件名 sed接多个指令 sed -e \u0026#39;s/旧的字符串/新的字符串/\u0026#39; -e \u0026#39;s/旧的字符串/新的字符串/\u0026#39; 文件名 首处替换 sed \u0026#39;s/text/replace_text/\u0026#39; file //替换每一行的第一处匹配的text 全局替换 sed \u0026#39;s/text/replace_text/g\u0026#39; file 默认替换后，输出替换后的内容，如果需要直接替换原文件,使用-i: sed -i \u0026#39;s/text/repalce_text/g\u0026#39; file 移除空白行 sed \u0026#39;/^$/d\u0026#39; file 第一个匹配的括号内容使用标记 1 来引用 sed \u0026#39;s/hello\\([0-9]\\)/\\1/\u0026#39; file Bash键盘技巧 # 将光标移到行首第一个字符 Ctl + a # 将光标移到行首第一个字符 Ctl + e # 删除光标到行首的所有字符 Ctl + u # 常用： # 删除输入的内容 Ctl + e + Ctl + u 归档与备份 gzip 压缩单个或多个文件\ngzip foo.text gunzip 解压文件\n# 压缩，生成foo.txt.gz gunzip foo.text zip 压缩和归档成 .zip 文件\nzip -r text.zip text unzip 解压 .zip 的文件\nunzip text.zip tar 归档多个文件或目录\n# 打包与 gzip 配合 tar -zcvf \u0026lt;打包压缩后的文件名\u0026gt; \u0026lt;要打包压缩的文件\u0026gt; z：调用 gzip 压缩命令进行压缩 c：打包文件 v：显示运行过程 f：指定文件名 # 解压 tar -zxvf test.tar.gz -C /usr**（- C 代表指定解压的位置） x：代表解包 磁盘管理 查看磁盘空间 # 查看磁盘空间利用大小:-h: human缩写，以易读的方式显示结果 df -hT # 查看当前目录所占空间大小，-s 递归整个目录的大小 du -sh # 查看当前目录下所有子文件夹排序后的大小: for i in `ls`; do du -sh $i; done | sort 或者： du -sh `ls` | sort 进程管理工具 查询进程 ps # 查询正在运行的进程信息: # VSZ-虚拟内存大小 RSS-该进程占用的 RAM 数量 ps -aux/ ps -ef top # 显示进程信息，并实时更新 top 打开后，输入M：按使用内存排序 打开后，输入P：按使用CPU排序,查看系统中使用CPU、使用内存最多的进程 打开后，输入i:使top不显示任何闲置或者僵死进程 打开后，输入q：退出 lsof # 查看端口占用的进程状态： lsof -i:3306 # 查看用户username的进程所打开的文件 lsof -u username # 查询init进程当前打开的文件 lsof -c init 其他 # 查询进程ID（适合只记得部分进程字段） pgrep -l \u0026lt;进程名\u0026gt; # 查看占用端口的进程 netstat -anp | grep port 终止进程 # 杀死指定PID的进程 (PID为Process ID) kill PID # 杀死相关进程 kill -9 3434 # 杀死job工作 (job为job number) kill %job 分析线程栈 使用命令pmap，来输出进程内存的状况，可以用来分析线程堆栈；\npmap PID 性能监控 监控CPU # 查看CPU使用率 sar -u eg: $sar -u 1 2 后面的两个参数表示监控的频率，比如例子中的1和2，表示每秒采样一次，总共采样2次； # 查看CPU平均负载，sar指定-q后，就能查看运行队列中的进程数、系统上的进程大小、平均负载等； sar -q 1 2 查询内存 # 查看内存使用状况 sar指定-r之后，可查看内存使用状况; sar -rh 1 2 # 查看内存使用量 free -mh 查询端口占用 # 查看当前系统端口使用情况 netstat -an # 展示进程加被占用的端口 netstat -ntlp 查询页面交换 查看页面交换发生状况 页面发生交换时，服务器的吞吐量会大幅下降；服务器状况不良时，如果怀疑因为内存不足而导致了页面交换的发生，可以使用sar -W这个命令来确认是否发生了大量的交换；\nsar -W 1 3 综合应用 当系统中sar不可用时，可以使用以下工具替代：linux下有 vmstat、Unix系统有prstat\neg： 查看cpu、内存、使用情况： vmstat n m （n 为监控频率、m为监控次数）\nvmstat 1 3 procs -----------memory---------- ---swap-- -----io---- -system-- ----cpu---- r b swpd free buff cache si so bi bo in cs us sy id wa 0 0 86560 42300 9752 63556 0 1 1 1 0 0 0 0 99 0 1 0 86560 39936 9764 63544 0 0 0 52 66 95 5 0 95 0 0 0 86560 42168 9772 63556 0 0 0 20 127 231 13 2 84 0 使用watch 工具监控变化 当需要持续的监控应用的某个数据变化时，watch工具能满足要求； 执行watch命令后，会进入到一个界面，输出当前被监控的数据，一旦数据变化，便会高亮显示变化情况；\neg：操作redis时，监控内存变化：\nwatch -d -n 1 \u0026#39;./redis-cli info | grep memory\u0026#39; (以下为watch工具中的界面内容，一旦内存变化，即实时高亮显示变化） Every 1.0s: ./redis-cli info | grep memory Mon Apr 28 16:10:36 2014 used_memory:45157376 used_memory_human:43.07M used_memory_rss:47628288 used_memory_peak:49686080 used_memory_peak_human:47.38M 系统网络状况 ping 向指定的主机发送 ICMP 数据包，用于确认与主机的网络连接。发送的时间间隔为 1 s，用 Ctrl + C中断发送，正常网络会显示 0% 的分组丢失率\n# 检查是否连网 ping www.baidu.com traceroute 会列出网络从本地到注定主机经过的所有跳数\n# 会显示经过路由器的主机名、IP地址及本地到该路由器3个往返时间采样数据 traceroute -I www.baidu.com ip 是一个多功能的网络配置工具，用于检查系统的网络接口和路由表\n会显示多个网络接口，常见接口： lo：环回接口，是一个虚拟接口，系统用于 “和自己对话” eth0: 以太网接口 接口第一行如果含有 UP字样，表明该接口已启用 第3行 inet 字段为该网络接口的 IP 地址 # ~$ ip a 1: lo: \u0026lt;LOOPBACK,UP,LOWER_UP\u0026gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever 2: eth0: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000 link/ether 00:16:3e:0e:a0:8b brd ff:ff:ff:ff:ff:ff inet 172.30.140.229/20 brd 172.30.143.255 scope global dynamic eth0 valid_lft 310094870sec preferred_lft 310094870sec inet6 fe80::216:3eff:fe0e:a08b/64 scope link valid_lft forever preferred_lft forever 3: docker0: \u0026lt;NO-CARRIER,BROADCAST,MULTICAST,UP\u0026gt; mtu 1500 qdisc noqueue state DOWN group default link/ether 02:42:53:b2:cd:34 brd ff:ff:ff:ff:ff:ff inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0 valid_lft forever preferred_lft forever netstat 用于检查各种网路设置和统计信息，需安装net-tools yum install net-tools\n# 检查系统的网络接口 netstat -ie # 查看所有网络连接 netstat -nt ssh 用于本地主机与远程主机进行通信\n# 需要输入 remote-sys 主机 ubuntu 用户的登录密码 ssh ubuntu@remote-sys 其他常用命令 # 常与别名命令 alias 一起使用，=号两边不能有空格，被别名的命令需要用单引号包含 alias ll=\u0026#39;ls -alh\u0026#39; # 查看两个文件间的差别: diff file1 file2 # 查看带有SVN的环境变量值： env | grep SVN 参考资料 Linux基础 - Linux Tools Quick Tutorial\nLinux命令手册\n工作中常用的的 Linux 命令\nLinux 命令搜索\n","permalink":"http://www.lmingyu.tech/posts/tech/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","summary":"\u003cblockquote\u003e\n\u003cp\u003e常用系列就是记录自己编程常用的东西，此文为常用系列第 1 篇，用于记录自己日常开发编程时常用的 Linux 命令，以便需要时查找。\u003c/p\u003e\n\u003c/blockquote\u003e","title":"常用系列-Linux 常用命令"},{"content":"","permalink":"http://www.lmingyu.tech/links/","summary":"","title":""},{"content":" 名字 Taiming Liang 坐标 广东 深圳 职业 后端程序员 描述 努力往独立开发者 💻 迈进 💪 尝试以英语为切入点重新认识世界 🌍 想以非功利的方式去阅读 📖 很高兴认识你! ─=≡Σ(((つ•̀ω•́)つ)) ","permalink":"http://www.lmingyu.tech/about/","summary":"名字 Taiming Liang 坐标 广东 深圳 职业 后端程序员 描述 努力往独立开发者 💻 迈进 💪 尝试以英语为切入点重新认识世界 🌍 想以非功利的方式去阅读 📖 很高兴认识你! ─=≡Σ","title":"👨‍💻个人画像"}]